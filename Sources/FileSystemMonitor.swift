import CoreServices
import Foundation
import Logging

/// Monitors file system events using FSEvents API.
@available(macOS 12, *)
public actor FileSystemMonitor {

    /// Logger instance for monitoring events and errors
    let logger: Logger

    /// Configuration options for file system monitoring behavior
    public struct Options: OptionSet, Sendable {
        public let rawValue: UInt32

        public init(rawValue: UInt32) {
            self.rawValue = rawValue
        }

        /// Report events for individual files (not just directories)
        public static let fileEvents = Options(
            rawValue: UInt32(kFSEventStreamCreateFlagFileEvents))
        /// Watch the root directory itself for changes
        public static let watchRoot = Options(
            rawValue: UInt32(kFSEventStreamCreateFlagWatchRoot))
        /// Ignore events generated by the current process
        public static let ignoreSelf = Options(
            rawValue: UInt32(kFSEventStreamCreateFlagIgnoreSelf))
        /// Mark events generated by the current process
        public static let markSelf = Options(
            rawValue: UInt32(kFSEventStreamCreateFlagMarkSelf))
        /// Don't defer event delivery
        public static let noDefer = Options(
            rawValue: UInt32(kFSEventStreamCreateFlagNoDefer))
    }

    /// Configuration for file system monitoring
    public struct Configuration: Sendable {
        /// File system paths to monitor
        public let paths: [String]
        /// Monitoring behavior options
        public let options: Options
        /// Time interval between event deliveries (in seconds)
        public let latency: TimeInterval
        /// Event ID to start monitoring from (nil for current events)
        public let sinceWhen: FSEventStreamEventId?
        /// Logger instance for monitoring events
        public let logger: Logger

        public init(
            paths: [String],
            options: Options = [],
            latency: TimeInterval = 0.1,
            sinceWhen: FSEventStreamEventId? = nil,
            logger: Logger = Logger(label: "me.mattt.FileSystemMonitor")
        ) {
            self.paths = paths
            self.options = options
            self.latency = latency
            self.sinceWhen = sinceWhen
            self.logger = logger
        }
    }

    /// Represents a file system event with associated metadata
    public struct Event: Sendable, Identifiable {
        /// Reasons why subdirectories must be scanned
        public enum MustScanSubDirsReason: Sendable {
            /// User dropped events (buffer overflow)
            case userDropped
            /// Kernel dropped events (system overload)
            case kernelDropped
            /// Unknown reason for dropping events
            case unknown
        }

        /// Represents different types of file system items
        public enum Item: Sendable {
            /// Regular file
            case file(path: String)
            /// Directory
            case dir(path: String)
            /// Symbolic link
            case symlink(path: String)
            /// Hard link
            case hardlink(path: String)
            /// Last hard link to an inode
            case lastHardlink(path: String)
            /// Unknown item type
            case unknown(path: String)

            /// The file system path of the item
            public var path: String {
                switch self {
                case .file(let path), .dir(let path), .symlink(let path),
                    .hardlink(let path), .lastHardlink(let path), .unknown(let path):
                    return path
                }
            }
        }

        /// The specific kind of file system event
        public enum Kind: Sendable {
            // MARK: - Basic Events
            /// Generic file system event at a path
            case generic(path: String)
            /// Directory requires scanning due to dropped events
            case mustScanSubDirs(path: String, reason: MustScanSubDirsReason)

            // MARK: - Stream Events
            /// Event IDs have wrapped around (rare)
            case eventIdsWrapped
            /// Historical event replay is complete
            case streamHistoryDone
            /// Root directory of watched path changed
            case rootChanged(path: String)

            // MARK: - Volume Events
            /// Volume was mounted
            case volumeMounted(path: String)
            /// Volume was unmounted
            case volumeUnmounted(path: String)

            // MARK: - File/Directory Events
            /// Item was created
            case itemCreated(item: Item)
            /// Item was removed
            case itemRemoved(item: Item)
            /// Item was renamed
            case itemRenamed(item: Item)
            /// Item's data was modified
            case itemDataModified(item: Item)

            // MARK: - Metadata Events
            /// Item's inode metadata was modified
            case itemInodeMetadataModified(item: Item)
            /// Item's Finder info was modified
            case itemFinderInfoModified(item: Item)
            /// Item's ownership was modified
            case itemOwnershipModified(item: Item)
            /// Item's extended attributes were modified
            case itemXattrModified(item: Item)
            /// Item was cloned at path
            case itemClonedAtPath(item: Item)
        }

        public let id: FSEventStreamEventId
        public let eventId: FSEventStreamEventId?
        public let fromUs: Bool?
        public let kind: Kind

        public init(
            eventId: FSEventStreamEventId? = nil,
            fromUs: Bool? = nil,
            kind: Kind
        ) {
            self.id = eventId ?? FSEventStreamEventId(0)
            self.eventId = eventId
            self.fromUs = fromUs
            self.kind = kind
        }

        /// The path associated with this event
        public var path: String {
            switch kind {
            case .generic(let path),
                .mustScanSubDirs(let path, _),
                .rootChanged(let path),
                .volumeMounted(let path),
                .volumeUnmounted(let path):
                return path
            case .itemCreated(let item),
                .itemRemoved(let item),
                .itemRenamed(let item),
                .itemDataModified(let item),
                .itemInodeMetadataModified(let item),
                .itemFinderInfoModified(let item),
                .itemOwnershipModified(let item),
                .itemXattrModified(let item),
                .itemClonedAtPath(let item):
                return item.path
            case .eventIdsWrapped, .streamHistoryDone:
                return ""
            }
        }

        /// The item associated with this event (if applicable)
        public var item: Item? {
            switch kind {
            case .itemCreated(let item),
                .itemRemoved(let item),
                .itemRenamed(let item),
                .itemDataModified(let item),
                .itemInodeMetadataModified(let item),
                .itemFinderInfoModified(let item),
                .itemOwnershipModified(let item),
                .itemXattrModified(let item),
                .itemClonedAtPath(let item):
                return item
            default:
                return nil
            }
        }

        // MARK: - Event Type Checking

        /// True if this is a file or directory creation event
        public var isCreation: Bool {
            if case .itemCreated = kind { return true }
            return false
        }

        /// True if this is a file or directory removal event
        public var isRemoval: Bool {
            if case .itemRemoved = kind { return true }
            return false
        }

        /// True if this is a file or directory rename event
        public var isRename: Bool {
            if case .itemRenamed = kind { return true }
            return false
        }

        /// True if this is a file or directory data modification event
        public var isDataModification: Bool {
            if case .itemDataModified = kind { return true }
            return false
        }

        /// True if this is a volume mount or unmount event
        public var isVolumeEvent: Bool {
            switch kind {
            case .volumeMounted, .volumeUnmounted:
                return true
            default:
                return false
            }
        }

        /// True if this is a metadata modification event
        public var isMetadataModification: Bool {
            switch kind {
            case .itemInodeMetadataModified, .itemFinderInfoModified,
                .itemOwnershipModified, .itemXattrModified:
                return true
            default:
                return false
            }
        }
    }

    // MARK: - Private Properties
    /// Core FSEventStream reference
    private nonisolated(unsafe) var eventStream: FSEventStreamRef?
    /// Flag indicating if monitoring is active
    private var isMonitoring = false
    /// Continuation for the event stream
    private let eventContinuation: AsyncStream<Event>.Continuation

    // MARK: - Public Properties
    /// Async stream of file system events
    nonisolated public let events: AsyncStream<Event>

    // MARK: - Initialization
    public init(configuration: Configuration) {
        self.logger = configuration.logger

        // Create the async stream for events
        let (eventStream, continuation) = AsyncStream<Event>.makeStream(
            bufferingPolicy: .bufferingNewest(1000))
        self.events = eventStream
        self.eventContinuation = continuation

        // Setup FSEventStream parameters
        let cfPathArray: CFArray = configuration.paths as CFArray
        let eventStartId =
            configuration.sinceWhen ?? FSEventStreamEventId(kFSEventStreamEventIdSinceNow)
        let streamFlags = FSEventStreamCreateFlags(
            kFSEventStreamCreateFlagUseCFTypes | Int(configuration.options.rawValue))

        // Create callback wrapper and context
        let callbackWrapper = FSEventStreamObjCWrapper()
        var streamContext = FSEventStreamContext(
            version: 0,
            info: Unmanaged.passUnretained(callbackWrapper).toOpaque(),
            retain: { ptrToRetain in
                guard let ptrToRetain = ptrToRetain else { return nil }
                let unmanaged = Unmanaged.passRetained(
                    Unmanaged<FSEventStreamObjCWrapper>.fromOpaque(ptrToRetain)
                        .takeUnretainedValue())
                return unsafeBitCast(unmanaged.takeUnretainedValue(), to: UnsafeRawPointer.self)
            },
            release: { ptrToRelease in
                guard let ptrToRelease = ptrToRelease else { return }
                Unmanaged<FSEventStreamObjCWrapper>.fromOpaque(ptrToRelease).release()
            },
            copyDescription: nil
        )

        // Create the FSEventStream
        self.eventStream = FSEventStreamCreate(
            kCFAllocatorDefault,
            eventStreamCallback,
            &streamContext,
            cfPathArray,
            eventStartId,
            configuration.latency,
            streamFlags
        )

        // Configure the stream
        if let eventStream = self.eventStream {
            FSEventStreamSetDispatchQueue(eventStream, DispatchQueue.main)
            callbackWrapper.monitor = self
        }

        // Handle stream termination
        continuation.onTermination = { [weak self] _ in
            Task { await self?.stop() }
        }
    }

    // MARK: - Public Control Methods
    /// Starts monitoring file system events
    public func start() {
        guard !isMonitoring, let eventStream = eventStream else { return }

        FSEventStreamStart(eventStream)
        isMonitoring = true
    }

    /// Stops monitoring file system events
    public func stop() {
        guard isMonitoring, let eventStream = eventStream else { return }

        FSEventStreamStop(eventStream)
        isMonitoring = false
    }

    /// Returns true if the monitor is actively watching for events
    public var isActive: Bool {
        isMonitoring
    }

    deinit {
        if isMonitoring, let eventStream = eventStream {
            FSEventStreamStop(eventStream)
        }
        if let eventStream = eventStream {
            FSEventStreamInvalidate(eventStream)
            FSEventStreamRelease(eventStream)
        }
        eventContinuation.finish()
    }

    nonisolated fileprivate func handleEvent(_ event: Event) {
        eventContinuation.yield(event)
    }
}

// MARK: - Event Processing Helpers
extension FileSystemMonitor {
    /// Determines the item type from event flags
    fileprivate static func extractItemType(from flags: FSEventStreamEventFlags, path: String)
        -> Event.Item
    {
        let itemTypeFlags =
            flags
            & FSEventStreamEventFlags(
                kFSEventStreamEventFlagItemIsFile
                    | kFSEventStreamEventFlagItemIsDir
                    | kFSEventStreamEventFlagItemIsSymlink
                    | kFSEventStreamEventFlagItemIsHardlink
                    | kFSEventStreamEventFlagItemIsLastHardlink
            )

        switch itemTypeFlags {
        case FSEventStreamEventFlags(kFSEventStreamEventFlagItemIsFile):
            return .file(path: path)
        case FSEventStreamEventFlags(kFSEventStreamEventFlagItemIsDir):
            return .dir(path: path)
        case FSEventStreamEventFlags(kFSEventStreamEventFlagItemIsSymlink):
            return .symlink(path: path)
        case FSEventStreamEventFlags(kFSEventStreamEventFlagItemIsHardlink):
            return .hardlink(path: path)
        case FSEventStreamEventFlags(kFSEventStreamEventFlagItemIsLastHardlink):
            return .lastHardlink(path: path)
        default:
            return .unknown(path: path)
        }
    }

    /// Determines the reason for must-scan-subdirs events
    fileprivate static func extractMustScanReason(from flags: FSEventStreamEventFlags)
        -> Event.MustScanSubDirsReason
    {
        let userDropped = (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagUserDropped)) != 0
        let kernelDropped =
            (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagKernelDropped)) != 0

        if userDropped && !kernelDropped {
            return .userDropped
        } else if !userDropped && kernelDropped {
            return .kernelDropped
        } else {
            return .unknown
        }
    }
}

private class FSEventStreamObjCWrapper: NSObject {
    weak var monitor: FileSystemMonitor?
}

/// Core callback function for FSEventStream events
/// This function processes raw FSEvents and converts them to structured Event objects
private func eventStreamCallback(
    streamRef: ConstFSEventStreamRef,
    clientCallBackInfo: UnsafeMutableRawPointer?,
    numEvents: Int,
    eventPathsAsVoidPtr: UnsafeMutableRawPointer,
    eventFlags: UnsafePointer<FSEventStreamEventFlags>,
    eventIds: UnsafePointer<FSEventStreamEventId>
) {
    // Extract the monitor instance from the callback context
    guard let clientCallBackInfo = clientCallBackInfo,
        let monitor = Unmanaged<FSEventStreamObjCWrapper>.fromOpaque(clientCallBackInfo)
            .takeUnretainedValue().monitor
    else {
        return
    }

    // Cast the void pointer to a string array
    guard let eventPaths = unsafeBitCast(eventPathsAsVoidPtr, to: CFArray.self) as? [String] else {
        monitor.logger.error(
            "Expected event paths to be a CFArray of CFStrings",
            metadata: [
                "pointer": .string(String(describing: eventPathsAsVoidPtr))
            ]
        )
        return
    }

    // Process each event in the batch
    for eventIndex in 0..<numEvents {
        let eventPath = eventPaths[eventIndex]
        let eventId = eventIds.advanced(by: eventIndex).pointee
        var flags = eventFlags.advanced(by: eventIndex).pointee

        // Extract "fromUs" flag if applicable (TODO: Implement mark self functionality)
        let fromUs: Bool? = nil
        flags = (flags & ~FSEventStreamEventFlags(kFSEventStreamEventFlagOwnEvent))

        // Handle generic events (no specific flags)
        if flags == kFSEventStreamEventFlagNone {
            monitor.handleEvent(
                FileSystemMonitor.Event(
                    eventId: eventId, fromUs: fromUs, kind: .generic(path: eventPath)
                )
            )
        } else {
            // Process events with specific flags
            processEventFlags(
                flags: flags,
                eventId: eventId,
                eventPath: eventPath,
                fromUs: fromUs,
                monitor: monitor
            )
        }
    }
}

/// Processes FSEventStream flags and generates appropriate Event objects
private func processEventFlags(
    flags: FSEventStreamEventFlags,
    eventId: FSEventStreamEventId,
    eventPath: String,
    fromUs: Bool?,
    monitor: FileSystemMonitor
) {
    // Determine the item type for file/directory events
    let itemType = FileSystemMonitor.extractItemType(from: flags, path: eventPath)
    var hasEmittedEvent = false

    // Check for must-scan-subdirs events
    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagMustScanSubDirs)) != 0 {
        let reason = FileSystemMonitor.extractMustScanReason(from: flags)
        monitor.handleEvent(
            FileSystemMonitor.Event(
                eventId: eventId, fromUs: fromUs,
                kind: .mustScanSubDirs(path: eventPath, reason: reason)
            )
        )
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagEventIdsWrapped)) != 0 {
        monitor.handleEvent(
            .init(eventId: nil, fromUs: nil, kind: .eventIdsWrapped))
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagHistoryDone)) != 0 {
        monitor.handleEvent(
            .init(eventId: nil, fromUs: nil, kind: .streamHistoryDone))
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagRootChanged)) != 0 {
        monitor.handleEvent(
            .init(
                eventId: eventId, fromUs: fromUs,
                kind: .rootChanged(path: eventPath)))
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagMount)) != 0 {
        monitor.handleEvent(
            .init(
                eventId: eventId, fromUs: fromUs,
                kind: .volumeMounted(path: eventPath)))
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagUnmount)) != 0 {
        monitor.handleEvent(
            .init(
                eventId: eventId, fromUs: fromUs,
                kind: .volumeUnmounted(path: eventPath))
        )
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagItemCreated)) != 0 {
        monitor.handleEvent(
            .init(
                eventId: eventId, fromUs: fromUs, kind: .itemCreated(item: itemType))
        )
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagItemRemoved)) != 0 {
        monitor.handleEvent(
            .init(
                eventId: eventId, fromUs: fromUs, kind: .itemRemoved(item: itemType))
        )
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagItemInodeMetaMod)) != 0 {
        monitor.handleEvent(
            .init(
                eventId: eventId, fromUs: fromUs,
                kind: .itemInodeMetadataModified(item: itemType)))
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagItemRenamed)) != 0 {
        monitor.handleEvent(
            .init(
                eventId: eventId, fromUs: fromUs, kind: .itemRenamed(item: itemType))
        )
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagItemModified)) != 0 {
        monitor.handleEvent(
            .init(
                eventId: eventId, fromUs: fromUs,
                kind: .itemDataModified(item: itemType)))
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagItemFinderInfoMod)) != 0 {
        monitor.handleEvent(
            .init(
                eventId: eventId, fromUs: fromUs,
                kind: .itemFinderInfoModified(item: itemType)))
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagItemChangeOwner)) != 0 {
        monitor.handleEvent(
            .init(
                eventId: eventId, fromUs: fromUs,
                kind: .itemOwnershipModified(item: itemType)))
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagItemXattrMod)) != 0 {
        monitor.handleEvent(
            .init(
                eventId: eventId, fromUs: fromUs,
                kind: .itemXattrModified(item: itemType)))
        hasEmittedEvent = true
    }

    if (flags & FSEventStreamEventFlags(kFSEventStreamEventFlagItemCloned)) != 0 {
        monitor.handleEvent(
            FileSystemMonitor.Event(
                eventId: eventId, fromUs: fromUs,
                kind: .itemClonedAtPath(item: itemType)))
        hasEmittedEvent = true
    }

    if !hasEmittedEvent {
        // We can't access the logger here since it's not accessible from nonisolated context
        // This is a fallback case for unknown events
        monitor.handleEvent(
            .init(
                eventId: eventId, fromUs: fromUs,
                kind: .generic(path: eventPath)))
    }
}

extension FileSystemMonitor {

    /// Convenience method to monitor a single path
    public static func monitor(
        path: String,
        options: Options = [],
        latency: TimeInterval = 0.1
    ) -> FileSystemMonitor {
        let configuration = Configuration(
            paths: [path],
            options: options,
            latency: latency
        )
        return FileSystemMonitor(configuration: configuration)
    }

    /// Monitor multiple paths with a unified event stream
    public static func monitor(
        paths: [String],
        options: Options = [],
        latency: TimeInterval = 0.1
    ) -> FileSystemMonitor {
        let configuration = Configuration(
            paths: paths,
            options: options,
            latency: latency
        )
        return FileSystemMonitor(configuration: configuration)
    }

    /// Monitor paths with automatic lifecycle management
    public static func withMonitoring<T>(
        paths: [String],
        options: Options = [],
        latency: TimeInterval = 0.1,
        operation: (FileSystemMonitor) async throws -> T
    ) async rethrows -> T {
        let monitor = FileSystemMonitor.monitor(
            paths: paths,
            options: options,
            latency: latency
        )

        await monitor.start()
        defer {
            Task { await monitor.stop() }
        }

        return try await operation(monitor)
    }

    /// Monitor a single path with automatic lifecycle management
    public static func withMonitoring<T>(
        path: String,
        options: Options = [],
        latency: TimeInterval = 0.1,
        operation: (FileSystemMonitor) async throws -> T
    ) async rethrows -> T {
        return try await withMonitoring(
            paths: [path],
            options: options,
            latency: latency,
            operation: operation
        )
    }
}

// MARK: - Configuration Extensions
extension FileSystemMonitor.Configuration {
    /// Create configuration for monitoring a single path
    public init(
        path: String,
        options: FileSystemMonitor.Options = [],
        latency: TimeInterval = 0.1,
        sinceWhen: FSEventStreamEventId? = nil,
        logger: Logger = Logger(label: "me.mattt.FileSystemMonitor")
    ) {
        self.init(
            paths: [path],
            options: options,
            latency: latency,
            sinceWhen: sinceWhen,
            logger: logger
        )
    }

    /// Create configuration for monitoring with file events enabled
    public static func withFileEvents(
        paths: [String],
        latency: TimeInterval = 0.1,
        logger: Logger = Logger(label: "me.mattt.FileSystemMonitor")
    ) -> Self {
        return Self(
            paths: paths,
            options: .fileEvents,
            latency: latency,
            logger: logger
        )
    }

    /// Create configuration for monitoring with file events enabled (single path)
    public static func withFileEvents(
        path: String,
        latency: TimeInterval = 0.1,
        logger: Logger = Logger(label: "me.mattt.FileSystemMonitor")
    ) -> Self {
        return Self(
            path: path,
            options: .fileEvents,
            latency: latency,
            logger: logger
        )
    }
}

// MARK: - Event Filtering Extensions
extension FileSystemMonitor {
    /// Filter events to only include file operations
    public var fileEvents: AsyncStream<Event> {
        events.filter { event in
            if let item = event.item {
                return item.path.isFile
            }
            return false
        }
    }

    /// Filter events to only include directory operations
    public var directoryEvents: AsyncStream<Event> {
        events.filter { event in
            if let item = event.item {
                return item.path.isDirectory
            }
            return false
        }
    }

    /// Filter events to only include creation events
    public var creationEvents: AsyncStream<Event> {
        events.filter { $0.isCreation }
    }

    /// Filter events to only include deletion events
    public var deletionEvents: AsyncStream<Event> {
        events.filter { $0.isRemoval }
    }

    /// Filter events to only include modification events
    public var modificationEvents: AsyncStream<Event> {
        events.filter { $0.isDataModification }
    }
}

// MARK: - Private Extensions
extension String {
    /// Check if the path represents a file
    fileprivate var isFile: Bool {
        var isDirectory: ObjCBool = false
        let exists = FileManager.default.fileExists(atPath: self, isDirectory: &isDirectory)
        return exists && !isDirectory.boolValue
    }

    /// Check if the path represents a directory
    fileprivate var isDirectory: Bool {
        var isDirectory: ObjCBool = false
        let exists = FileManager.default.fileExists(atPath: self, isDirectory: &isDirectory)
        return exists && isDirectory.boolValue
    }
}

extension AsyncStream where Element == FileSystemMonitor.Event {
    /// Filter events based on a predicate
    fileprivate func filter(_ predicate: @escaping @Sendable (Element) -> Bool) -> AsyncStream<
        Element
    > {
        return AsyncStream { continuation in
            Task {
                for await event in self {
                    if predicate(event) {
                        continuation.yield(event)
                    }
                }
                continuation.finish()
            }
        }
    }
}
